import os
import sys
import json
import time
import shutil
import zipfile
import logging
import aiohttp
import openpyxl
import requests
import warnings
import simplekml
import xml.etree.ElementTree as ET

# import teste
from functools import wraps
import mysql.connector
import pandas as pd
import matplotlib.pyplot as plt
import contextily as cx
import io

##fim import teste

from pathlib import Path
from telegram import Update
from openpyxl import Workbook
from dotenv import load_dotenv
from Scripts_Alexo import selecionar_token, __version__
from telegram.ext import ApplicationBuilder, CommandHandler, ContextTypes, MessageHandler, filters, ApplicationHandlerStop


caminho_env = Path(__file__).parent / ".env"
load_dotenv(dotenv_path=caminho_env)

warnings.filterwarnings("ignore", category=UserWarning)

class IgnoreAttributeErrorFilter(logging.Filter):
    def filter(self, record):
        return "AttributeError" not in record.getMessage()

def send_log_to_telegram(message):
    url = f'https://api.telegram.org/bot{BOT_TOKEN}/sendMessage'
    payload = {
        'chat_id': TELEGRAM_GROUP_ID,
        'text': message,
        'parse_mode': 'Markdown'
    }
    requests.post(url, json=payload)


logger = logging.getLogger()
logger.setLevel(logging.INFO)

console_handler = logging.StreamHandler()
console_handler.setLevel(logging.INFO)
console_formatter = logging.Formatter('%(asctime)s - %(levelname)s - %(message)s')
console_handler.setFormatter(console_formatter)
console_handler.addFilter(IgnoreAttributeErrorFilter())


logger.addHandler(console_handler)


__author__ = "Alexandre B, J. Ayrton"
__credits__ = "Anderson, Josimar"

FileName = "WebHook.json"
sys.tracebacklimit = 0

DBUG = 2


try:
    BOT_TOKEN = selecionar_token(DBUG)
except ValueError as e:

    logger.error(f"Erro: {e}")


TELEGRAM_GROUP_ID = "-1002292627707"

ErroE101 = "❌ Atenção, excesso de argumentos. Verifique o comando informado e tente novamente!"
ErroP101 = "❌ Atenção, 'POP' não informado!"
ErroP102 = "❌ Atenção, 'POP' não existe na lista de templates. Verifique se foi informado corretamente ou notifique a equipe interna."
ErroF101 = "❌ Atenção, 'FSAN/SN' não informado para a consulta. Verifique o comando e tente novamente!"
ErroF102 = "❌ Atenção, o formato do campo 'FSAN/SN' está incorreto!"
ErroS101 = "❌ Atenção, 'SPLITTER' não informado. Verifique o comando e tente novamente!"
ErroN101 = "❌ Atenção, 'OLT/SLOT/PON' não informado. Verifique o comando e tente novamente!"
ErroN102 = "❌ Atenção, 'OLT/SLOT/PON' contém mais de duas '/'. Verifique o comando e tente novamente!"
ErroC101 = "❌ Atenção, verifique se a 'CTO' informada está correta e tente novamente."


#TESTE CONEXÃO COM BANCO DE DADOS

def criar_conexao_db():
    try:
        conexao = mysql.connector.connect(
            host=os.getenv("DB_HOST", "localhost"),
            user=os.getenv("DB_USER"),
            password=os.getenv("DB_PASSWORD"),
            database="bot_sql"
        )
        return conexao
    except mysql.connector.Error as err:
        logger.error(f"Erro ao conectar ao MySQL: {err}")
        return None

def admin_required(func):
    """
    Decorador que verifica se o usuário é um administrador
    antes de executar uma função de comando.
    """
    @wraps(func)
    async def wrapper(update: Update, context: ContextTypes.DEFAULT_TYPE, *args, **kwargs):
        user_id = update.effective_user.id
        
        conexao_db = None
        cursor = None
        try:
            conexao_db = criar_conexao_db()
            if not conexao_db:
                await update.message.reply_text("⚠️ Erro interno ao verificar permissões.")
                return

            cursor = conexao_db.cursor()
            
            # --- LINHA CORRIGIDA ---
            # Alterado de 'user_id' para 'id_telegram' para corresponder à sua tabela.
            query = "SELECT is_admin FROM usuarios WHERE id_telegram = %s"
            
            cursor.execute(query, (user_id,))
            resultado = cursor.fetchone()

            if resultado and resultado[0]:
                return await func(update, context, *args, **kwargs)
            else:
                logger.warning(f"Acesso negado para o id_telegram {user_id} ao comando {func.__name__}")
                await update.message.reply_text("❌ Você não tem permissão para usar este comando.")
                return

        except mysql.connector.Error as err:
            logger.error(f"Erro de banco de dados na verificação de admin: {err}")
            await update.message.reply_text("⚠️ Ocorreu um erro ao verificar suas permissões.")
        finally:
            if cursor:
                cursor.close()
            if conexao_db and conexao_db.is_connected():
                conexao_db.close()

    return wrapper


from telegram import Update
from telegram.ext import ContextTypes, CommandHandler

async def listar_admins(update: Update, context: ContextTypes.DEFAULT_TYPE) -> None:
    """Lista todos os administradores do chat atual."""
    chat_id = update.effective_chat.id
    
    try:
        # Pede à API do Telegram a lista de administradores do chat
        administradores = await context.bot.get_chat_administrators(chat_id)
        
        if not administradores:
            await update.message.reply_text("Não foi possível encontrar administradores neste grupo.")
            return

        # Formata a lista para exibição
        lista_texto = ["*Administradores do Grupo*:\n"]
        for admin in administradores:
            user = admin.user
            lista_texto.append(f"- *{user.full_name}* (ID: `{user.id}`)")

        mensagem = "\n".join(lista_texto)
        await update.message.reply_text(mensagem, parse_mode='Markdown')

    except Exception as e:
        logger.error(f"Erro ao listar administradores: {e}")
        await update.message.reply_text("Ocorreu um erro ao buscar a lista de administradores. Verifique se o bot tem permissão para isso.")

#FIM TESTE CONEXÃO

# --- Função para buscar CTOs no Banco de Dados ---
def buscar_ctos_proximas(lat, lon):
    """
    Busca no banco de dados todas as CTOs em um raio de 150 metros
    da localização fornecida usando a fórmula de Haversine.
    """
    conexao_db = None
    cursor = None
    ctos_encontradas = []

    # O raio em quilômetros (150m = 0.15 km)
    raio_km = 0.15
    
    # A consulta SQL com a fórmula de Haversine
    # 6371 é o raio da Terra em km.
    query_haversine = """
        SELECT cto, latitude, longitude,
               (6371 * ACOS(
                   COS(RADIANS(%s)) * COS(RADIANS(latitude)) *
                   COS(RADIANS(longitude) - RADIANS(%s)) +
                   SIN(RADIANS(%s)) * SIN(RADIANS(latitude))
               )) AS distancia
        FROM ctos
        HAVING distancia <= %s
        ORDER BY distancia;
    """

    try:
        conexao_db = criar_conexao_db()
        if not conexao_db:
            logger.error("Não foi possível conectar ao DB para buscar CTOs.")
            return None # Retorna None em caso de falha de conexão

        # Usamos dictionary=True para acessar os resultados por nome da coluna
        cursor = conexao_db.cursor(dictionary=True)
        cursor.execute(query_haversine, (lat, lon, lat, raio_km))
        ctos_encontradas = cursor.fetchall()
        
        return ctos_encontradas

    except mysql.connector.Error as err:
        logger.error(f"Erro de SQL ao buscar CTOs próximas: {err}")
        return None # Retorna None em caso de erro de SQL
    finally:
        if cursor:
            cursor.close()
        if conexao_db and conexao_db.is_connected():
            conexao_db.close()

# --- Função para criar a imagem do mapa ---
def criar_mapa_ctos(user_lat, user_lon, ctos_encontradas):
    """
    Cria uma imagem de mapa com buffer/margem dinâmica para melhor visualização.
    """
    # Cria DataFrames para facilitar os cálculos
    df_ctos = pd.DataFrame(ctos_encontradas)
    df_user = pd.DataFrame([{'latitude': user_lat, 'longitude': user_lon}])
    
    # Junta todos os pontos em um único DataFrame
    all_points = pd.concat([
        df_ctos[['latitude', 'longitude']], 
        df_user[['latitude', 'longitude']]
    ])

    # Converte para numérico, tratando possíveis erros de dados
    all_points['latitude'] = pd.to_numeric(all_points['latitude'], errors='coerce')
    all_points['longitude'] = pd.to_numeric(all_points['longitude'], errors='coerce')
    all_points.dropna(inplace=True)

    # --- INÍCIO DA LÓGICA DO BUFFER DINÂMICO ---

    # 1. Encontra a extensão dos dados (o quão espalhados os pontos estão)
    lat_range = all_points.latitude.max() - all_points.latitude.min()
    lon_range = all_points.longitude.max() - all_points.longitude.min()

    # 2. Define a margem como uma porcentagem da maior extensão

    padding_percentage = 0.10 
    lat_buffer = lat_range * padding_percentage
    lon_buffer = lon_range * padding_percentage

    # Garante um buffer mínimo para quando os pontos estão muito juntos (ou é um ponto só)
   
    min_buffer_value = 0.002
    if lat_buffer < min_buffer_value: lat_buffer = min_buffer_value
    if lon_buffer < min_buffer_value: lon_buffer = min_buffer_value

    # 3. Calcula os novos limites do mapa
    min_lat = all_points.latitude.min() - lat_buffer
    max_lat = all_points.latitude.max() + lat_buffer
    min_lon = all_points.longitude.min() - lon_buffer
    max_lon = all_points.longitude.max() + lon_buffer

    # --- FIM DA LÓGICA DO BUFFER DINÂMICO ---

    # Cria a figura e os eixos do mapa
    fig, ax = plt.subplots(figsize=(10, 10))
    ax.axis('off') # Mantém os eixos desligados

    # Aplica os limites dinâmicos ao mapa
    ax.set_xlim(min_lon, max_lon)
    ax.set_ylim(min_lat, max_lat)

    # Plota as CTOs e o usuário (nenhuma mudança aqui)
    ax.scatter(df_ctos.longitude, df_ctos.latitude, c='red', s=60, zorder=2, label='CTOs Próximas', edgecolors='black')
    for idx, row in df_ctos.iterrows():
        ax.text(row.longitude, row.latitude + (lat_buffer * 0.04), f'{row.cto}', fontsize=10, zorder=3, ha='center', fontweight='bold')
    ax.scatter(user_lon, user_lat, c='blue', s=250, marker='*', zorder=4, label='Sua Localização', edgecolors='white')
    
    # Adiciona o mapa de fundo
    cx.add_basemap(ax, crs='EPSG:4326', source=cx.providers.OpenStreetMap.Mapnik)
    
    # Salva a imagem em memória
    buf = io.BytesIO()
    plt.savefig(buf, format='png', bbox_inches='tight', pad_inches=0)
    plt.close(fig)
    buf.seek(0)
    
    return buf

# --- Handler para o comando /ctos ---
async def ctos(update: Update, context: ContextTypes.DEFAULT_TYPE):
    """Pede ao usuário para enviar a localização para encontrar CTOs próximas."""
    # Define um estado para aguardar a localização específica para este comando
    context.user_data['waiting_for_ctos_location'] = True
    await update.message.reply_text("📍 Por favor, envie sua localização para que eu possa encontrar as CTOs mais próximas.")

# --- Handler para receber a localização ---
async def handle_ctos_location(update: Update, context: ContextTypes.DEFAULT_TYPE):
    """
    Recebe a localização APENAS para o comando /ctos.
    """
    # 1. Verifica se o bot estava esperando uma localização para ESTE comando.
    if not context.user_data.get('waiting_for_ctos_location'):
        # Se não, simplesmente retorna e não faz NADA.
        # A biblioteca passará para o próximo handler no próximo grupo.
        return

    # 2. Se era para este comando, executa a lógica e limpa o estado.
    context.user_data['waiting_for_ctos_location'] = False
    
    location = update.message.location
    user_lat = location.latitude
    user_lon = location.longitude

    await update.message.reply_text("Buscando CTOs em um raio de 150 metros... 📡")
    
    ctos_encontradas = buscar_ctos_proximas(user_lat, user_lon)
    
    if ctos_encontradas is None:
        await update.message.reply_text("❌ Ocorreu um erro ao acessar o banco de dados.")
    elif not ctos_encontradas:
        await update.message.reply_text("Nenhuma CTO foi encontrada no raio de 150 metros.")
    else:
        try:
            mapa_buffer = criar_mapa_ctos(user_lat, user_lon, ctos_encontradas)
            nomes_ctos = "\n".join([f"- {cto['cto']}" for cto in ctos_encontradas])
            await context.bot.send_photo(
                chat_id=update.effective_chat.id,
                photo=mapa_buffer,
                caption=f"✅ Encontrei {len(ctos_encontradas)} CTO(s) próximas:\n{nomes_ctos}"
            )
        except Exception as e:
            logger.error(f"Falha ao gerar ou enviar o mapa de CTOs: {e}")
            await update.message.reply_text("❌ Ocorreu um erro ao gerar o mapa.")

    # 3. Garante que nenhum outro handler de localização será executado para este update.
    raise ApplicationHandlerStop
        
    # 2. Cria a imagem do mapa
    try:
        mapa_buffer = criar_mapa_ctos(user_lat, user_lon, ctos_encontradas)
        
        # 3. Envia o mapa como uma foto
        nomes_ctos = "\n".join([f"- {cto['cto']}" for cto in ctos_encontradas])
        await context.bot.send_photo(
            chat_id=update.effective_chat.id,
            photo=mapa_buffer,
            caption=f"✅ Encontrei {len(ctos_encontradas)} CTO(s) próximas:\n{nomes_ctos}"
        )
    except Exception as e:
        logger.error(f"Falha ao gerar ou enviar o mapa de CTOs: {e}")
        await update.message.reply_text("❌ Ocorreu um erro ao gerar o mapa. A equipe de desenvolvimento foi notificada.")

# fim do teste
class TelegramHandler(logging.Handler):
    def emit(self, record):
        log_entry = self.format(record)
        send_log_to_telegram(log_entry)

telegram_handler = TelegramHandler()
telegram_handler.setLevel(logging.INFO)
telegram_formatter = logging.Formatter('%(asctime)s - %(levelname)s - %(message)s')
telegram_handler.setFormatter(telegram_formatter)

logger.addHandler(telegram_handler)

logging.getLogger("aiohttp").setLevel(logging.WARNING)
logging.getLogger("telegram").setLevel(logging.WARNING)
logging.getLogger("httpx").setLevel(logging.WARNING)
logging.getLogger("urllib3").setLevel(logging.WARNING)

SPLITTERS_VALIDOS = {"1/16", "1/8", "1/4"}

import glob

def ExcluirArquivos(caminho_arquivo):
    pasta, nome_base_ext = os.path.split(caminho_arquivo)
    nome_base, ext = os.path.splitext(nome_base_ext)

    # Procura todas as versões do arquivo no diretório
    arquivos_encontrados = glob.glob(os.path.join(pasta, f"{nome_base}*{ext}"))

    if arquivos_encontrados:
        for arquivo in arquivos_encontrados:
            try:
                os.remove(arquivo)
                print(f"✅ Arquivo excluído: {arquivo}")
            except Exception as e:
                print(f"❌ Erro ao excluir '{arquivo}': {e}")
    else:
        logger.info(f"Erro ao excluir um arquivo - ⚠️ Nenhuma versão do arquivo encontrada para exclusão: {caminho_arquivo}")

def ExcluirArquivosporExtensao():
    diretorio = Path("")
    extensoes = [".xlsx", ".kml", ".kmz"]
    for arquivo in diretorio.iterdir():
        if arquivo.suffix in extensoes:
            arquivo.unlink()
            logger.info(f"Ajuste do diretório raiz - Excluído: {arquivo}")



def kml_to_xlsx(kml_file, xlsx_file):
    tree = ET.parse(kml_file)
    root = tree.getroot()
    namespaces = {'kml': 'http://www.opengis.net/kml/2.2'}

    wb = Workbook()
    ws = wb.active
    ws.title = "Placemarks"
    ws.append(["PLACEMARK", "LATITUDE", "LONGITUDE"])

    for placemark in root.findall(".//kml:Placemark", namespaces):
        name = placemark.find("kml:name", namespaces)
        coordinates = placemark.find(".//kml:coordinates", namespaces)
        
        if name is not None and coordinates is not None:
            coord_text = coordinates.text.strip()
            coord_parts = coord_text.split(",")
            
            if len(coord_parts) >= 2:
                lat, lon = coord_parts[:2]
                ws.append([name.text, lon.strip(), lat.strip()])
    
    wb.save(xlsx_file)


def ListaCidades():
    try:
        with open(FileName, 'r', encoding='utf-8') as file:
            dados = json.load(file)

        cidades = [f"{i + 1}. {entry['POP']} - {entry['CIDADE']}" for i, entry in enumerate(dados)]
        return "\n".join(cidades)
    
    except FileNotFoundError:
        return "Arquivo não encontrado."
    
    except json.JSONDecodeError:
        return "Erro ao ler o arquivo JSON."

def buscar_webhook_por_pop(pop):
    try:
        with open(FileName, 'r', encoding='utf-8') as arquivo_json:
            dados = json.load(arquivo_json)

        for entry in dados:
            if entry["POP"].upper() == pop.upper():
                return entry["WEBHOOK_LINK"]

        return None
    
    except FileNotFoundError:
        return "Arquivo não encontrado."
    
    except json.JSONDecodeError:
        return "Erro ao ler o arquivo JSON."



def buscar_cidade_por_pop(pop):
    try:
        with open(FileName, 'r', encoding='utf-8') as arquivo_json:
            dados = json.load(arquivo_json)

        for entry in dados:
            if entry["POP"].upper() == pop.upper():
                return entry["CIDADE"]

        return None
    
    except FileNotFoundError:
        return "Arquivo não encontrado."
    
    except json.JSONDecodeError:
        return "Erro ao ler o arquivo JSON."

def buscar_dir_drive():
    try:
        with open("config_drive.json", "r", encoding="utf-8") as f:
            dados = json.load(f)
            return dados.get("diretorio", "❌ Diretório não encontrado no arquivo.")
    except FileNotFoundError:
        return "❌ Arquivo de configuração não encontrado."


async def EnviaArquivosDrive(dirarquivo, xlsx_file, chat_id, context, kmz_file=None, new_kml_file=None):
    # Verifica se o diretório existe, se não, cria
    if not os.path.exists(dirarquivo):
        os.makedirs(dirarquivo)

    # Nome do arquivo no destino
    nome_base, ext = os.path.splitext(os.path.basename(xlsx_file))
    caminho_destino = os.path.join(dirarquivo, os.path.basename(xlsx_file))

    # Se o arquivo já existir, criar versões incrementais
    contador = 1
    while os.path.exists(caminho_destino):
        contador += 1
        novo_nome = f"{nome_base}_v{contador}{ext}"
        caminho_destino = os.path.join(dirarquivo, novo_nome)

    # Verifica se o arquivo existe antes de mover
    if os.path.exists(xlsx_file):
        shutil.move(xlsx_file, caminho_destino)
        mensagem = f"📂 Arquivo salvo no drive:\n\nNome do arquivo:\n{os.path.basename(caminho_destino)}\n\nDiretório do arquivo:\n{dirarquivo}"
        
        if contador > 1:
            mensagem += f"\n\n⚠️ O arquivo já existia e foi salvo como versão v{contador}."
        
        await context.bot.send_message(chat_id, mensagem)
    else:
        await context.bot.send_message(chat_id, f"❌ Arquivo não encontrado: {xlsx_file}")

    
def encontrar_arquivo_kml_kmz(DirArquivo):
    if not os.path.exists(DirArquivo):
        logger.info(f"Encontrar arquivo - ❌ Diretório não encontrado: {DirArquivo}")

        return None

    for arquivo in os.listdir(DirArquivo):
        if arquivo.endswith((".kml", ".kmz")):
            return os.path.join(DirArquivo, arquivo)  # Retorna o caminho completo do arquivo
    return None 




def extract_kml_from_kmz(kmz_file, extract_to):
    with zipfile.ZipFile(kmz_file, 'r') as kmz:
        for file in kmz.namelist():
            if file.endswith('.kml'):
                kmz.extract(file, extract_to)
                kml_file = os.path.join(extract_to, file)
                new_kml_file = os.path.join(extract_to, os.path.splitext(os.path.basename(kmz_file))[0] + '.kml')
                os.rename(kml_file, new_kml_file)
                return new_kml_file
    return 


async def converter_planilha_template_para_kml(CaminhoXLSX_Converter, Caminho_ConvertKML, NomePlanilha_ConvertKML, IconeUrl_ConvertKML, chat_id, context):
    """Essa função cria o kml acessando o template na planilha KMZ e gera o KMZ BASE"""

    #ACESSO AO DRIVE


    try:
        workbook = openpyxl.load_workbook(CaminhoXLSX_Converter)

        if NomePlanilha_ConvertKML not in workbook.sheetnames:
            logger.info(f"Converter arquivo - ❌ A planilha '{NomePlanilha_ConvertKML}' não foi encontrada.")
            logger.info(f"📄 Planilhas disponíveis: {workbook.sheetnames}")
            return
        
        sheet = workbook[NomePlanilha_ConvertKML]

        kml = simplekml.Kml()

        # Lê os dados a partir da terceira linha (ignorando cabeçalho)
        for row in sheet.iter_rows(min_row=3, values_only=True):
            nome = row[0]  # Coluna A (Nome do ponto)
            lat = row[1]   # Coluna B (Latitude)
            lon = row[2]   # Coluna C (Longitude)

            # Verifica se os valores são válidos
            if nome and lat and lon:
                pnt = kml.newpoint(name=str(nome), coords=[(lon, lat)])  # (Longitude, Latitude)

                # Define o ícone do ponto
                pnt.style.iconstyle.icon.href = IconeUrl_ConvertKML
                pnt.style.iconstyle.scale = 1.5  # Tamanho do ícone

        kml.save(Caminho_ConvertKML)
        with open(Caminho_ConvertKML, "rb") as arquivo:
            await context.bot.send_document(chat_id, document=arquivo, caption=f"Arquivo KML gerado com sucesso:\n    {Caminho_ConvertKML}")

        workbook.close()
    
    except Exception as e:
        logger.erro(f"❌ Erro ao processar o arquivo: {e}")

def DE_KMZ_BASE_PARA_TEMPLATE(arquivo_origem, arquivo_destino):
    """Copia os dados das colunas A, B e C do arquivo de origem para O 'TEMPLATE' na planilha'KMZ' no arquivo de destino."""

    #ACESSO AO DRIVE

    try:
        wb_origem = openpyxl.load_workbook(arquivo_origem)
        sheet_origem = wb_origem.active  # Usa a primeira planilha
        
        wb_destino = openpyxl.load_workbook(arquivo_destino)

        if "KMZ" not in wb_destino.sheetnames:
            sheet_destino = wb_destino.create_sheet("KMZ")  # Cria a planilha se não existir
        else:
            sheet_destino = wb_destino["KMZ"]

        for row_idx, row in enumerate(sheet_origem.iter_rows(min_row=3, values_only=True), start=3):
            sheet_destino[f"A{row_idx}"] = row[0]  # Coluna A (Nome do ponto)
            sheet_destino[f"B{row_idx}"] = row[1]  # Coluna B (Latitude)
            sheet_destino[f"C{row_idx}"] = row[2]  # Coluna C (Longitude)

        wb_destino.save(arquivo_destino)

        print("✅ Dados copiados com sucesso para a planilha 'KMZ'!")

    except Exception as e:
        logger.erro(f"❌ Erro ao copiar os dados: {e}")


async def VerificarTemplatemporPOP(DirTemplate, PopInformado_user, update):
    """Essa função verifica se o template existe no diretório do drive e se o POP informado corresponde ao esperado."""
    # Verifica se a pasta existe antes de tentar listar os arquivos
    if os.path.exists(DirTemplate):
        for arquivo in os.listdir(DirTemplate):
            if arquivo.startswith("TEMPLATE REDES") and arquivo.endswith(".gsheet"):
                partes = arquivo.replace(".gsheet", "").split()

                if len(partes) >= 3:  # Verifica se há pelo menos três partes (padrão + POP + cidade)
                    pop = partes[2]  # O POP é a terceira palavra no nome do arquivo
                    
                    # ✅ Verificação: POP deve ter no máximo 3 letras
                    if pop == PopInformado_user:  # Verifica se o POP é igual ao valor esperado
                        caminho_arquivo = os.path.join(DirTemplate, arquivo)
                        logger.info(f"handle_mensagem - POP: {pop} - Arquivo encontrado: {caminho_arquivo}")
                    else:
                        logger.info(f"handle_mensagem - POP: {pop} não corresponde ao esperado.")
    else:
        await update.message.reply_text(
            f"Erro ao acessar o template no diretório do drive.\n\n"
            f"| Informações recebidas:\nCaminho recebido do Template:\n{DirTemplate}"
        )


async def ajuda(update: Update, context: ContextTypes.DEFAULT_TYPE):
    chat_id = update.effective_chat.id
    chat_title = update.effective_chat.title
    user = update.effective_user

    comandos = [
        "| Ajuda - BOT-ALEXO",
        "\n\n- Atividades 🌟",
        "    /Atividades <POP>",
        "    Verifica se existem atividades pendentes no template.",
        "    EX: /Atividades TIE",

        "\n\n- Checar 🔍",
        "    /Checar <CTO> <FSAN>",
        "    Verifica OLT/SLOT/PON do cliente na CTO.",
        "    EX: /Checar TIE-001 FHTT0000000",

        "\n\n- Localizar 📍",
        "    /Localizar <CTO>",
        "    Retorna a localização de uma CTO.",
        "    EX: /Localizar TIE-001",

        "\n\n- Input 📝",
        "    /Input <CTO> <SPLITER>",
        "    Inputa as informações de data e splitter para o template.",
        "    EX: /Input TIE-001 1/16",

        "\n\n- Insert 📝",
        "    /Insert <CTO> <OLT/SLOT/PON>",
        "    Inputa as informações da CTO e splitter para o template na aba checar.",
        "    EX: /Insert TIE-001 1/1/1",

        "\n\n- Listar IDS 📋",
        "    /ListarIDs <POP> <OLT/SLOT/PON>",
        "    /TESTE",
        "    EX: /Input TIE-001 1/16",

        "\n\n- Nova CTO ➕",
        "    /NovaCTO <POP> <OLT/SLOT/PON> <SPLITER>",
        "    CTO QUE NÃO EXISTE NO KMZ.",
        "    EX: /NovaCTO TIE 1/1/1 1/16",

        "\n\n| Informações ℹ️:",
        f"    Versão: {__version__}",
        f"    Criadores: {__author__}",
        f"    Créditos:   {__credits__}"
    ]

    comandos_texto = "\n".join(comandos)

    logger.info(f"/Ajuda - Usuário:{user.first_name} {user.last_name}, Grupo:{chat_title}")

    await context.bot.send_message(chat_id=chat_id, text=comandos_texto)


async def fetch_data(webhook_link, payload):
    try:    
        # Criação da sessão HTTP assíncrona
        async with aiohttp.ClientSession() as session:
            # Requisição POST ao webhook
            async with session.post(webhook_link, json=payload) as response:
                response_data = await response.json()

                if response.status == 200:
                    logger.info(f"Google App Script - Resposta: {response_data}")
                    return response_data
                else:
                    logger.error(f"Erro ao conectar ao Apps Script: {response.status} - {response.reason}")
                    return {
                        "status": "error",
                        "message": f"Erro ao conectar ao servidor: {response.reason}."
                    }

    except aiohttp.ClientError as client_error:
        logger.error(f"Erro de cliente HTTP: {client_error}")
        return {"status": "error", "message": "Erro de comunicação com o servidor."}

    except Exception as e:
        logger.error(f"/fetch_data - Exceção inesperada: {e}")
        return {"status": "error", "message": f"Erro inesperado: {str(e)}"}



async def atividades(update: Update, context: ContextTypes.DEFAULT_TYPE):
    chat_id = update.effective_chat.id
    chat_title = update.effective_chat.title
    user = update.effective_user

    if len(context.args) < 1:
        await update.message.reply_text(text=ErroP101)
        return

    pop = context.args[0]
    pop = str(pop.upper())
    pop = pop.split('-')[0]

    webhook_link = buscar_webhook_por_pop(pop)

    if webhook_link is None:
        await update.message.reply_text(ErroP102)
        return

    payload = {"comando": "Atividades", "id": chat_id}

    logger.info(f"RECEBIDO: /Atividades - POP:{pop} - Usuário:{user.first_name} {user.last_name}, Grupo:{chat_title}")

    try:
        data = await fetch_data(webhook_link, payload)
    except Exception as e:
        logger.error(f"Erro ao buscar dados: {e}")
        await update.message.reply_text(text="⚠️ Erro ao processar a solicitação.")
        return
    
    if data.get("status") == "sucesso":
        await context.bot.send_message(chat_id=chat_id, text=f"{data.get('mensagem')}")
        logger.info(f"Atividade: {data.get('mensagem')}")
    else:
        ErroWH104 = (
            "WH104."
            "\n\n| VERIFICAR SE A SIGLA DO POP FOI INFORMADO CORRETAMENTE!"
            "\n\nCaso persistir, informar o erro à equipe interna com urgência!"
            "\n\nCONTATOS:"
            "\n     - @J_Ayrton"
            "\n     - @AlexandreBarros_Desktop"
        )
        error_message = data.get("mensagem", ErroWH104)

        logger.error(f"ERRO WH104: COMANDO /Atividades - POP:{pop} - Usuário:{user.first_name} {user.last_name}, Grupo:{chat_title}")

        await context.bot.send_message(chat_id=chat_id, text=f"⚠️ Erro 1: {error_message}")

    return webhook_link


async def checar(update: Update, context: ContextTypes.DEFAULT_TYPE):
    chat_id = update.effective_chat.id
    chat_title = update.effective_chat.title
    user = update.effective_user


    if len(context.args) < 1:
        await update.message.reply_text(text=ErroP101)
        return

    if len(context.args) < 2:
        await update.message.reply_text(text=ErroF101)
        return

    cto, fsan = context.args[:2]

    cto = str(cto.upper())
    pop = cto.split('-')[0]

    VerificarIfen_CTO = cto.count('-')
    if VerificarIfen_CTO > 1 or VerificarIfen_CTO < 1:
        await update.message.reply_text(text=ErroC101)
        return

    if '/' in fsan or '-' in fsan:
        await update.message.reply_text(text=ErroF102)
        return

    webhook_link = buscar_webhook_por_pop(pop)

    if webhook_link is None:
        await update.message.reply_text(ErroP102)
        return

    payload = {"comando": "Checar", "cto": cto, "fsan": fsan}

    logger.info(f"/Checar recebido - CTO: {cto}, FSAN: {fsan} - Usuário:{user.first_name} {user.last_name}, Grupo:{chat_title}")
    data = await fetch_data(webhook_link, payload)

    if data.get("status") == "sucesso":
        await update.message.reply_text(text=f"{data.get('confirmacao')}")
    else:
        await update.message.reply_text(text=f" 6: {data.get('mensagem')}")
    return webhook_link

async def localizar_cto(update: Update, context: ContextTypes.DEFAULT_TYPE):
    chat_id = update.effective_chat.id
    chat_title = update.effective_chat.title
    user = update.effective_user

    if len(context.args) < 1:
        await update.message.reply_text(text=ErroP101)
        return

    cto = context.args[0].upper()

    VerificarIfen_CTO = cto.count('-')
    if VerificarIfen_CTO > 1 or VerificarIfen_CTO < 1:
        await update.message.reply_text(text=ErroC101)
        return

    pop = cto.split('-')[0]
    webhook_link = buscar_webhook_por_pop(pop)

    if webhook_link is None:
        await update.message.reply_text(ErroP102)
        return

    payload = {"comando": "Localizar", "cto": cto}

    logger.info(f"/Localizar recebido - POP: {pop}, CTO: {cto} - Usuário:{user.first_name} {user.last_name}, Grupo:{chat_title}")
    
    data = await fetch_data(webhook_link, payload)

    if data.get("status") == "sucesso":
        await update.message.reply_text(text=f"{data.get('mensagem')}")
    else:
        await update.message.reply_text(text=f"⚠️ CTO NÃO ENCONTRADO!")


async def ExibirCidade(update: Update, context: ContextTypes.DEFAULT_TYPE):
    chat_title = update.effective_chat.title
    user = update.effective_user

    cidade = ListaCidades()

    await update.message.reply_text(text=f"🌆 Cidades disponíveis:\n\n{cidade}")

    logger.info(f"/ExibirCidade recebido - Usuário:{user.first_name} {user.last_name}, Grupo:{chat_title}")
    

async def input(update: Update, context: ContextTypes.DEFAULT_TYPE):
    chat_title = update.effective_chat.title or "Chat Privado"
    user = update.effective_user


    if len(context.args) < 1:
        await update.message.reply_text(text=ErroP101)
        return

    if len(context.args) < 2:
        await update.message.reply_text(text=ErroS101)
        return

    cto, splitter = context.args[:2]

    VerificarIfen_CTO = cto.count('-')
    if VerificarIfen_CTO > 1 or VerificarIfen_CTO < 1:
        await update.message.reply_text(text=ErroC101)
        return

    VerificarBarra_SPL = splitter.count('/')
    if VerificarBarra_SPL > 1 or VerificarBarra_SPL < 1:
        await update.message.reply_text(text=ErroN102)
        return

    VerificarIfen_CTO = cto.count('-')
    if VerificarIfen_CTO > 1 or VerificarIfen_CTO < 1:
        await update.message.reply_text(text=ErroC101)
        return

    cto = cto.upper()
    pop = cto.split('-')[0]
    webhook_link = buscar_webhook_por_pop(pop)

    if webhook_link is None:
        await update.message.reply_text(ErroP102)
        return

    splitters = {"16", "8", "4"}
    splitter_final = splitter.split("/")[-1]
    if splitter_final not in splitters:
        await update.message.reply_text(
            text=f"❌ SPLITTER inválido! Use apenas 1/16, 1/8, 1/4."
        )
        return

    payload = {"comando": "Input", "cto": cto, "splitter": splitter_final}

    logger.info(f"/Input recebido - POP: {pop}, CTO: {cto} - Usuário:{user.first_name} {user.last_name}, Grupo:{chat_title}")
    
    try:
        data = await fetch_data(webhook_link, payload)
    except Exception as e:
        logger.error(f"/Input recebido - POP: {pop}, CTO: {cto}, {e} - Usuário:{user.first_name} {user.last_name}, Grupo:{chat_title}")
        await update.message.reply_text(
            text="⚠️ Erro interno ao processar sua solicitação. Tente novamente mais tarde."
        )
        return

    if data.get("status") == "sucesso":
        await update.message.reply_text(text=f"{data.get('confirmacao')}")
    else:
        await update.message.reply_text(text=f" ⚠️ Erro 5: {data.get('mensagem')}")


async def AjudaAdm(update: Update, context: ContextTypes.DEFAULT_TYPE):
    user = update.effective_user
    chat_id = update.effective_chat.id
    chat_title = update.effective_chat.title or "Chat Privado"
    
    comandos = (
        "| AjudaAdm:"

        "\n\n>>> Principais comandos"
        "\n\n - EXIBIR O ID DO GRUPO:"
        "\n    /id"

        "\n\n- EXIBIR CIDADES SALVAS:"
        "\n    /ExibirCidade"

        "\n\n- EXCLUIR TEMPLATE EXISTENTE:"
        "\n    /ExcluirTemplate <cidade>"

        "\n\n- ADICIONAR NOVO TEMPLATE:"
        "\n    /AddTemplate <cidade> <POP> <WebHook>" 

        "\n\n- Compartilhar Webhook.json:"
        "\n    /CWH"

        "\n\n- Converter Arquivo KMZ ou KML em arquivo .XLSX:"
        "\n    /Convert"
        "\n    Fluxo do comando:"
        "\n        0. Finalizar o comando /Convert"
        "\n        1. Enviar o arquivo KMZ ou KML para o Driver:"
        "\n            - Informar o pop da cidade que deseja salvar o arquivo"
        "\n        2. Insertar os points no template e salvar os arquivos"
        "\n            - Informar o pop da cidade que deseja salvar o arquivo"


        "\n\n- Baxar KMZ da pasta 'kmz e kml' no drive:"
        "\n    /BaixarKMZ <POP>"

        "\n\n- Gerar KML BASE apartir do template:"
        "\n    /GerarKMZ <POP>"

        "\n\n>>> Pastas compartilhadas"

        "\n\n- Grupo de logger:"
        "\n    https://t.me/+Ij5OdRrCgAVkNTIx"

        "\n\n- One Driver Backup:"
        "\n    https://1drv.ms/f/s!AltzaXN7TtjqkqR0OQJ0jYa9VSyhWg?e=bb1LEy"


        "\n\n| *Quando o nome da cidade conter 'espaço' lembre-se \n de subistituir por hífen '-'."
    )

    await context.bot.send_message(chat_id=chat_id, text=comandos)

    logger.info(f"/ajudaadm - Usuário:{user.first_name} {user.last_name}, Grupo:{chat_title}")
    
@admin_required
async def CWH(update: Update, context: ContextTypes.DEFAULT_TYPE):
    user = update.effective_user
    chat_id = update.effective_chat.id
    chat_title = update.effective_chat.title or "Chat Privado"

    logger.info(f"/CWH - Usuário:{user.first_name} {user.last_name}, Grupo:{chat_title}")
    
    chat_id = update.effective_chat.id
    arquivo = open('WebHook.json', 'rb')
    await context.bot.send_document(chat_id=chat_id, document=arquivo)
    
@admin_required
async def AdcionarTemplate(update: Update, context: ContextTypes.DEFAULT_TYPE):
    chat_id = update.effective_chat.id
    chat_title = update.effective_chat.title
    user = update.effective_user

    def ADC_WEBHOOK(CIDADE_ID, POP, WEBHOOK_LINK):
        novo_dado = {
            'CIDADE': CIDADE_ID,
            'POP': POP,
            'WEBHOOK_LINK': WEBHOOK_LINK
        }

        if os.path.exists(FileName):
            try:
                with open(FileName, 'r', encoding='utf-8') as arquivo_json:
                    dados_existentes = json.load(arquivo_json)
            except json.JSONDecodeError:
                dados_existentes = []
        else:
            dados_existentes = []

        dados_existentes.append(novo_dado)
        with open(FileName, 'w', encoding='utf-8') as arquivo_json:
            json.dump(dados_existentes, arquivo_json, ensure_ascii=False, indent=4)

    if not update.message:
        print("Erro: Não foi possivel capturar o update do Webhook.")
        return

    if len(context.args) < 3:
        await update.message.reply_text(
            text=(
                "❌ Formato inválido!\n\n"
                "Use: /AdcionarTemplate <CIDADE> <POP> <WEBHOOK>\n\n"
                "Exemplo:\n/AdcionarTemplate Rio_Claro RCA https://script.google.com/macros..."
            )
        )
        return

    CIDADE_ID, POP, WEBHOOK_LINK = context.args[:3]
    CIDADE_ID = CIDADE_ID.upper()
    POP = POP.upper()

    ADC_WEBHOOK(CIDADE_ID, POP, WEBHOOK_LINK)

    cidade = ListaCidades()

    await update.message.reply_text(text=f"✅ Novo template adicionado:\n\n- CIDADE: {CIDADE_ID}\n- POP: {POP}\n- WEBHOOK: {WEBHOOK_LINK}")
    await update.message.reply_text(text=f"Lista de cidades existentes:\n\n{cidade}")

    logger.info(f"/AdcionarTemplate - CIDADE:{CIDADE_ID}, POP:{POP} - Usuário:{user.first_name} {user.last_name}, Grupo:{chat_title}")

@admin_required
async def ExcluirTemplate(update: Update, context: ContextTypes.DEFAULT_TYPE):
    chat_id = update.effective_chat.id
    chat_title = update.effective_chat.title
    user = update.effective_user
    

    MensagemErro = "❌ Formato inválido!\n\n Use: /ExcluirTemplate <POP>\n    - Ex: /ExcluirTemplate TIE\n    * Importante que o nome da cidade seja exatamente igual ao registrado."

    if len(context.args) < 1:
        await update.message.reply_text(text=MensagemErro)
        return


    ExcluirCidade = '-'.join(context.args).upper()

    logger.info(f"/ExcluirTemplate - cidade:{ExcluirCidade} - Usuário:{user.first_name} {user.last_name}, Grupo:{chat_title}")

    with open(FileName, 'r') as file:
        dados = json.load(file)

    dados_atualizados = [POP for POP in dados if POP['POP'] != ExcluirCidade]

    if len(dados) == len(dados_atualizados):
        await update.message.reply_text(text=f"⚠️ A cidade {ExcluirCidade} não foi encontrada.")
    else:
        with open(FileName, 'w') as file:
            json.dump(dados_atualizados, file, indent=4)

        await update.message.reply_text(text=f"✅ O POP '{ExcluirCidade}' foi excluído com sucesso!")
        cidade = ListaCidades()
        await update.message.reply_text(text=f"Lista de cidades existentes:\n\n{cidade}")


async def id(update: Update, context: ContextTypes.DEFAULT_TYPE):
    chat_id = update.effective_chat.id
    chat_title = update.effective_chat.title
    user = update.effective_user
    user_id=update.effective_user.id

    logger.info(f"/id - Usuário:{user.first_name} {user.last_name}, Grupo:{chat_title}")
    
    await update.message.reply_text(f"\nA ID deste grupo é: {chat_id}, "
                                    f"\nNome do grupo: {chat_title},"
                                    f"\nID do Usuario: {user_id}")
@admin_required
async def Info(update: Update, context: ContextTypes.DEFAULT_TYPE):
    chat_id = update.effective_chat.id
    chat_title = update.effective_chat.title
    user = update.effective_user


    Inf = (
        "| Nome do BOT: Alexo"
        "\n\n - Alexo tem o intuito de ser um auxílio para os usuários técnicos, back-offices e internos, com a capacidade de gerar de editar plalhas inopputando informações direto do chat, assim reduzindo as margens se erros na inputação de diversos procedimentos por todas as equipes."
        f"\n\nVersão: {__version__}"
        f"\n\nCriador: {__author__}"
        f"\nCréditos: {__credits__}"
    )

    logger.info(f"/Info - Usuário:{user.first_name} {user.last_name}, Grupo:{chat_title}")

    await update.message.reply_text(Inf)

async def listarIDs(update: Update, context: ContextTypes.DEFAULT_TYPE):
    chat_id = update.effective_chat.id
    chat_title = update.effective_chat.title
    user = update.effective_user


    if len(context.args) < 1:
        await update.message.reply_text(text=ErroP101)
        return
    
    if len(context.args) < 2:
        await update.message.reply_text(text=ErroS101)
        return
    
    pop, OLT_SLOT_PON = context.args[:2]
    pop = pop.upper()
    pop = pop.split('-')[0]

    VerificarBarra = OLT_SLOT_PON.count('/')
    if VerificarBarra > 2 or VerificarBarra < 2:
        await update.message.reply_text(text=ErroN102)
        return

    partes = OLT_SLOT_PON.split("/")

    olt = partes[0] 
    slot = partes[1]
    pon = partes[2] 


    payload = {"comando": "ListarIds", "olt": olt, "slot": slot, "pon": pon}

    logger.info(f"/ListarIDs - OLT:{olt}, SLOT:{slot}, PON:{pon} - Usuário:{user.first_name} {user.last_name}, Grupo:{chat_title}")


    webhook_link = buscar_webhook_por_pop(pop)

    if webhook_link is None:
        await update.message.reply_text(ErroP102)
        return
    
    data = await fetch_data(webhook_link, payload)

    if data.get("status") == "sucesso":
        ctos = data.get('mensagem')
        ctos_com_contador = [f"{i+1}. {cto}" for i, cto in enumerate(ctos)]
        ctos_com_contador_str = '\n'.join(ctos_com_contador)
        await update.message.reply_text(text=f"IDs disponiveis:\n\n{ctos_com_contador_str}\n\n| Sempre use o Ids da CTO de número [1]")
    else:
        await update.message.reply_text(text=f"⚠️ Erro 4: {data.get('mensagem')}")

async def insert(update: Update, context: ContextTypes.DEFAULT_TYPE):
    chat_title = update.effective_chat.title
    user = update.effective_user


    if len(context.args) < 1:
        await update.message.reply_text(text=ErroP101)
        return
    
    if len(context.args) < 2:
        await update.message.reply_text(text=ErroN101)
        return
    
    CTO, OLT_SLOT_PON = context.args[:2]
    
    CTO = str(CTO.upper())
    POP = CTO.split('-')[0]

    VerificarIfen_CTO = CTO.count('-')
    if VerificarIfen_CTO > 1 or VerificarIfen_CTO < 1:
        await update.message.reply_text(text=ErroC101)
        return

    VerificarBarra = OLT_SLOT_PON.count('/')
    if VerificarBarra > 2 or VerificarBarra < 2:
        await update.message.reply_text(text=ErroN102)
        return

    if "/" in OLT_SLOT_PON:
        partes = OLT_SLOT_PON.split("/")
        
        olt = partes[0]
        slot = partes[1]
        pon = partes[2]

    else:
        olt = OLT_SLOT_PON.upper()
        slot = ""
        pon = ""

    payload = {"comando": "Insert", "cto": CTO, "olt": olt, "slot": slot, "pon": pon}

    logger.info(f"/Insert - CTO:{CTO}, PON:{OLT_SLOT_PON} - Usuário:{user.first_name} {user.last_name}, Grupo:{chat_title}")


    webhook_link = buscar_webhook_por_pop(POP)

    if webhook_link is None:
        await update.message.reply_text(ErroP102)
        return
    
    data = await fetch_data(webhook_link, payload)

    print(data)

    if data.get("status") == "sucesso":
        ctos = data.get('mensagem')
        await update.message.reply_text(text=f"{ctos}")
    else:
        await update.message.reply_text(text=f"⚠️ Erro 3: {data.get('mensagem')}")


async def novaCTO(update: Update, context: ContextTypes.DEFAULT_TYPE):
    chat_id = update.effective_chat.id
    chat_title = update.effective_chat.title
    user = update.effective_user

    if len(context.args) < 1:
        await update.message.reply_text(text=ErroP101)
        return
    
    if len(context.args) < 2:
        await update.message.reply_text(text=ErroN101)
        return
    
    if len(context.args) < 3:
        await update.message.reply_text(text=ErroS101)
        return

    pop = context.args[0]
    pop = pop.split('-')[0]

    olt_slot_pon = context.args[1]
    VerificarBarra = olt_slot_pon.count('/')
    if VerificarBarra > 2 or VerificarBarra < 2:
        await update.message.reply_text(text=ErroN102)
        return


    splitter = context.args[2]

    VerificarBarra_SPL = splitter.count('/')
    if VerificarBarra_SPL > 1 or VerificarBarra_SPL < 1:
        await update.message.reply_text(text=ErroN102)
        return

    splitters = {"16", "8", "4"}
    splitter_final = splitter.split("/")[-1]

    if splitter_final not in splitters:
        await update.message.reply_text(
            text="❌ SPLITTER inválido! Use apenas 1/16, 1/8, 1/4."
        )
        return 
    await update.message.reply_text(
        text="📍 Por favor, envie a localização da CTO que deseja adicionar."
    )

    context.user_data['waiting_for_location'] = True
    context.user_data['pop'] = pop
    context.user_data['olt_slot_pon'] = olt_slot_pon
    context.user_data['splitter'] = splitter
    context.user_data['splitter_final'] = splitter_final

    logger.info(f"/NovaCTO - POP:{pop}, PON:{olt_slot_pon}, SPL:{splitter} - Usuário:{user}, Grupo:{chat_title}")


async def handle_location(update: Update, context: ContextTypes.DEFAULT_TYPE):
    if not context.user_data.get('waiting_for_location'):
        return
    
    context.user_data['waiting_for_location'] = False
    chat_title = update.effective_chat.title or "Chat Privado"
    chat_id = update.effective_chat.id
    user = update.effective_user.username or "Usuário Privado"
    user_id = update.effective_user.id


    def EquipeWH(chat_title, chat_id, user, user_id):
        FileNameEquipe = "EquipeWH.json"

        Novo_DadosEquipe = {
            'NomeEquipe': chat_title,
            'ID_Equipe': chat_id,
            'NomeTec': f"{user}",
            'ID_Tec': user_id,
        }

        if os.path.exists(FileNameEquipe):
            try:
                with open(FileNameEquipe, 'r', encoding='utf-8') as arquivo_json:
                    dados_existentes = json.load(arquivo_json)
            except json.JSONDecodeError:
                dados_existentes = []
        else:
            dados_existentes = []

        dados_existentes.append(Novo_DadosEquipe)
        with open(FileNameEquipe, 'w', encoding='utf-8') as arquivo_json:
            json.dump(dados_existentes, arquivo_json, ensure_ascii=False, indent=4)

    EquipeWH(chat_title, chat_id,user,user_id)

    if update.message and update.message.location:
        location = update.message.location
        latitude = location.latitude
        longitude = location.longitude
        accuracy = location.horizontal_accuracy if location.horizontal_accuracy else "Desconhecida"

        if context.user_data.get('waiting_for_location'):
            pop = context.user_data.get('pop')
            webhook_link = buscar_webhook_por_pop(pop)

            if webhook_link is None:
                await update.message.reply_text(ErroP102)
                return

            olt_slot_pon = context.user_data.get('olt_slot_pon')
            splitter = context.user_data.get('splitter')

            splitter_final = splitter.split("/")[-1]
            if splitter_final not in {"16", "8", "4"}:
                await update.message.reply_text(
                    text="❌ Formato do spliter inválido! [1]"
                )
                return

            filtros = olt_slot_pon.split("/")
            if len(filtros) != 3:
                await update.message.reply_text("❌ Formato da pon inválido! [2]")
                return

            olt, slot, pon = filtros

            payload = {
                "comando": "NovaCto",
                "olt": olt,
                "slot": slot,
                "pon": pon,
                "latitude": latitude,
                "longitude": longitude,
                "splitter": splitter_final,
                "id": chat_id
            }

            await update.message.reply_text(
                text=f"📍 Localização recebida: {latitude}, {longitude}\n"
                     f"Precisão: {accuracy} metros\n"
                     f"POP: {pop}\n"
                     f"OLT/SLOT/PON: {olt_slot_pon}\n"
                     f"Splitter: {splitter}\n"
                     "\nEnviando as informações para o template, aguarde..."
            )

            logger.info(f"payload: {payload} ////// Localização /NovaCTO recebida - Usuário:{user}, Grupo:{chat_title}")

            data = await fetch_data(webhook_link, payload)

            if data.get("status") == "sucesso":
                await update.message.reply_text(text=f"{data.get('mensagem')}")
            else:
                await update.message.reply_text(text=f"⚠️ Erro 2: {data.get('mensagem')}")

            context.user_data['waiting_for_location'] = False

        else:
            chat_title = update.effective_chat.title
            
            logger.info(f"Localização recebida - Usuário:{user}, Grupo:{chat_title}")

            Msg_Localizacao = f"📍 - Informações da localização\n\n| Coordenadas: {latitude}, {longitude}\n| Precisão: {accuracy} metros\n\n| Link-Maps: https://www.google.pt/maps?q={latitude},{longitude}"

            await update.message.reply_text(text=Msg_Localizacao)
    else:
        if update.message:
            await update.message.reply_text("❌ Não foi possível obter a localização. Por favor, envie uma localização válida.")
        else:
            pass
    raise ApplicationHandlerStop

async def convert(update: Update, context: ContextTypes.DEFAULT_TYPE):
    chat_id = update.effective_chat.id
    user = update.effective_user
    context.user_data['waiting_for_file'] = True
    await update.message.reply_text("Por favor, envie o arquivo KML/KMZ que você deseja converter.")


async def handle_arquivo(update: Update, context: ContextTypes.DEFAULT_TYPE):
    chat_id = update.effective_chat.id
    user = update.effective_user

    if context.user_data.get('waiting_for_file'):

        if update.message and update.message.document:
            document = update.message.document
            file_id = document.file_id
            file_name = document.file_name
            file_extension = file_name.split('.')[-1]

            file = await context.bot.get_file(file_id)
            file_path = f"{file_name}"

            await file.download_to_drive(file_path)

            logger.info(f"Arquivo Recebido - Arquivo:{file_name} - Usuário:{user.first_name} {user.last_name}")

            if file_extension == 'kml':
                Arq = "KML"
                xlsx_file = file_path.replace(file_extension, 'xlsx')
                kml_to_xlsx(file_path, xlsx_file)

                Mensagem_User = f"📄 - Conversor KML para XLSX: \n\nArquivo: {file_name}\nFomarto do arquivo: {Arq}\nConvertido para: XLSX\nNovo Arquivo: {xlsx_file}"
                OpcMSG_text = "Digite uma opção:\n\n[0] - Sair\n\n[1] - Apenas salvar a planilha no drive\n[2] - Inputar points no template e salvar a planilha no Drive"

                await update.message.reply_text(text=Mensagem_User)
                await context.bot.send_document(chat_id=chat_id, document=open(xlsx_file, 'rb'))
                await update.message.reply_text(f"{OpcMSG_text}")
                context.user_data['MsgUser_ApplyPointTemplates'] = True
                context.user_data['xlsx_file'] = xlsx_file  

                


            elif file_extension == 'kmz':
                extract_to = ""
                kml_file = extract_kml_from_kmz(file_path, extract_to)
                if kml_file:
                    xlsx_file = kml_file.replace('kml', 'xlsx')
                    Arq = "KMZ"
                    kml_to_xlsx(kml_file, xlsx_file)

                    Mensagem_User = f"📄 - Conversor KMZ para XLSX: \n\nArquivo: {file_name}\nFomarto do arquivo: {Arq}\nConvertido para: XLSX\nNovo Arquivo: {xlsx_file}"
                    OpcMSG_text = "Digite uma opção:\n\n[0] - Sair\n\n[1] - Apenas salvar a planilha no drive\n[2] - Inputar points no template e salvar a planilha no Drive"


                    await update.message.reply_text(text=Mensagem_User)
                    await context.bot.send_document(chat_id=chat_id, document=open(xlsx_file, 'rb'))
                    
                    await update.message.reply_text(f"{OpcMSG_text}")
                    context.user_data['MsgUser_ApplyPointTemplates'] = True
                    context.user_data['xlsx_file'] = xlsx_file  

                    


                else:
                    await update.message.reply_text("❌ Não foi possível extrair o arquivo KML do arquivo KMZ.")

            else:
                await update.message.reply_text(text=f"📄 Arquivo recebido: {file_name}\nTamanho: {document.file_size} bytes\nFile ID: {file_id}")
            
            context.user_data['waiting_for_file'] = False

        else:
            await update.message.reply_text("❌ Não foi possível identificar o arquivo. Por favor, envie um arquivo válido.")
    
    else:
        pass


async def configdrive(update: Update, context: ContextTypes.DEFAULT_TYPE):
    chat_id = update.effective_chat.id
    user = update.effective_user

    # Verifica se o usuário passou um argumento
    if context.args:
        DirDrive = context.args[0]

        # Criar um dicionário com os dados
        dados = {"diretorio": DirDrive}

        # Salvar no arquivo JSON
        with open("config_drive.json", "w", encoding="utf-8") as f:
            json.dump(dados, f, ensure_ascii=False, indent=4)

        await update.message.reply_text(f"✅ Diretório salvo: {DirDrive}")

    else:
        await update.message.reply_text("❌ Você precisa informar um diretório! Exemplo: /configdrive nome_da_pasta")


async def baixarkmz(update: Update, context: ContextTypes.DEFAULT_TYPE):
    if context.args:
        pop = context.args[0]
        pop = pop.split('-')[0]

        NomeCidade = buscar_cidade_por_pop(pop).replace("-", " ")
        LinkDrive = buscar_dir_drive()

        Pastakmz = f"{NomeCidade}/kmz e kml"

        dirarquivo = os.path.join(LinkDrive, Pastakmz)


        arquivo = encontrar_arquivo_kml_kmz(DirArquivo=dirarquivo)
        print(f"Caminho gerado: {dirarquivo}")
        print(f"Caminho gerado: {arquivo}")

        if arquivo:
            await update.message.reply_document(document=open(arquivo, "rb"))
            await update.message.reply_text(f"📄 Arquivo enviado: {os.path.basename(arquivo)}")
        else:
            await update.message.reply_text("❌ Nenhum arquivo KML/KMZ encontrado no diretório.")

    else:
        await update.message.reply_text("❌ Você precisa informar um POP válido!")

async def gerarkmzatualizado(update: Update, context: ContextTypes.DEFAULT_TYPE):
    chat_id = update.effective_chat.id
    user = update.effective_user

    if context.args:
        POP_ConvertKML = context.args[0]
        POP_ConvertKML = POP_ConvertKML.split('-')[0]  # Pega apenas a primeira parte antes do "-"
        POP_ConvertKML = str(POP_ConvertKML.upper())

        NomeCidade_ConvertKML = buscar_cidade_por_pop(POP_ConvertKML)
        
        if NomeCidade_ConvertKML:
            NomeCidade_ConvertKML = NomeCidade_ConvertKML.replace("-", " ")
            
        else:
            print(f"❌ Não foi possível encontrar a cidade para o POP: {POP_ConvertKML}")
            return
        
        NomeCidade_ConvertKML = NomeCidade_ConvertKML.replace("-", " ")

        print(NomeCidade_ConvertKML)
        
        #await VerificarTemplatemporPOP(NomeCidade_ConvertKML, POP_ConvertKML, update)

        LinkDrive = buscar_dir_drive()

        Pastakmz = f"{LinkDrive}{NomeCidade_ConvertKML}/kmz e kml"
        CaminhoXLSX_Converter = NomeCidade_ConvertKML

        dirarquivo = os.path.join(Pastakmz)
        NomePlanilha_ConvertKML = "KMZ"
        IconeUrl_ConvertKML = "http://maps.google.com/mapfiles/kml/shapes/placemark_circle.png" #Define o icone do arquivo kml
        Caminho_ConvertKML = f"{POP_ConvertKML} - {NomeCidade_ConvertKML} - KMZ BASE.kml"
        
        await context.bot.send_message(chat_id, "Gerando KML, aguarde...")
        await converter_planilha_template_para_kml(CaminhoXLSX_Converter, Caminho_ConvertKML, NomePlanilha_ConvertKML, IconeUrl_ConvertKML, chat_id, context)

    else:
        await update.message.reply_text("❌ Você precisa informar um POP válido!")

async def handle_mensagem(update: Update, context: ContextTypes.DEFAULT_TYPE):
    chat_id = update.effective_chat.id
    user = update.effective_user
    mensagem = update.message.text  # Captura a mensagem do usuário

    # Se o usuário está na primeira etapa de escolha (1 ou 2)
    if context.user_data.get('MsgUser_ApplyPointTemplates'):
        if mensagem == "1":  # FLUXO 1
            context.user_data['selected_flow'] = 1
            context.user_data['MsgUser_ApplyPointTemplates'] = False  # Reseta a flag
            context.user_data['waiting_for_pop_1'] = True  # Ativa o fluxo 1
            await context.bot.send_message(chat_id, "📌 O fluxo [1] foi selecionado!\n\nPor favor, informe o POP para continuar.")

        elif mensagem == "2":  # FLUXO 2
            context.user_data['selected_flow'] = 2
            context.user_data['MsgUser_ApplyPointTemplates'] = False  
            context.user_data['waiting_for_pop_2'] = True  # Ativa o fluxo 2
            await context.bot.send_message(chat_id, "📌 O fluxo [2] foi selecionado!\n\nPor favor, informe o POP para continuar.")

        else:
            await update.message.reply_text("Comando 'convert' finalizado.")
            context.user_data['MsgUser_ApplyPointTemplates'] = False  # Reseta a flag
            context.user_data['waiting_for_pop_1'] = False
            context.user_data['waiting_for_pop_2'] = False
        return
    
    # --- FLUXO 1: Processa o POP informado ---
    if context.user_data.get('waiting_for_pop_1'):
        NomeCidade = buscar_cidade_por_pop(update.message.text)

        if NomeCidade:
            NomeCidade = NomeCidade.replace("-", " ")
            LinkDrive = buscar_dir_drive()
            caminho_do_arquivo = os.path.join(LinkDrive, NomeCidade, "ARQUIVOS AUXILIARES")
            print(caminho_do_arquivo)

            xlsx_file = context.user_data.get('xlsx_file', "arquivo_padrão.xlsx")
            kmz_file = context.user_data.get('kmz_file')  # Obtendo o kmz_file armazenado
            new_kml_file = context.user_data.get('new_kml_file')  # Obtendo o new_kml_file armazenado

            # Chama a função para salvar o arquivo no diretório
            await EnviaArquivosDrive(caminho_do_arquivo, xlsx_file, chat_id, context, kmz_file, new_kml_file)
            context.user_data['waiting_for_pop_1'] = False 
            ExcluirArquivosporExtensao()
            
        else:
            await update.message.reply_text("❌ POP não encontrado na lista de templates! Digite novamente:")
            ExcluirArquivosporExtensao()
        

    # --- FLUXO 2: Processa o POP informado ---
    if context.user_data.get('waiting_for_pop_2'):
        PopInformado_user = update.message.text
        PopInformado_user = PopInformado_user.upper()
        NomeCidade = buscar_cidade_por_pop(PopInformado_user)

        if NomeCidade:
            NomeCidade = NomeCidade.replace("-", " ")
            LinkDrive = buscar_dir_drive()
            caminho_do_arquivo = os.path.join(LinkDrive, NomeCidade, "ARQUIVOS AUXILIARES")

            xlsx_file = context.user_data.get('xlsx_file', "arquivo_padrão.xlsx")
            kmz_file = context.user_data.get('kmz_file')  # Obtendo o kmz_file armazenado
            new_kml_file = context.user_data.get('new_kml_file')  # Obtendo o new_kml_file armazenado

            DirTemplate = os.path.join(LinkDrive, NomeCidade, "CEP CTO")

            await VerificarTemplatemporPOP(DirTemplate, PopInformado_user, update)

            
        # Chama a função para salvar o arquivo no diretório
        await EnviaArquivosDrive(caminho_do_arquivo, xlsx_file, chat_id, context, kmz_file, new_kml_file)

        #DE_KMZ_BASE_PARA_TEMPLATE(xlsx_file, caminho_arquivo)

        ExcluirArquivosporExtensao()
        context.user_data['waiting_for_pop_2'] = False  

    else:
        await update.message.reply_text("❌ POP não encontrado na lista de templates! Digite novamente:")
        context.user_data['waiting_for_pop_1'] = False
        context.user_data['waiting_for_pop_2'] = False
        ExcluirArquivosporExtensao()



if __name__ == "__main__":
    app = ApplicationBuilder().token(BOT_TOKEN).build()


    app.add_handler(CommandHandler("BaixarKmz", baixarkmz))
    app.add_handler(CommandHandler("GerarKmz", gerarkmzatualizado))

    app.add_handler(CommandHandler("Id", id))
    app.add_handler(CommandHandler("CWH", CWH))
    app.add_handler(CommandHandler("Info", Info))
    app.add_handler(CommandHandler("Input", input))
    app.add_handler(CommandHandler("Ajuda", ajuda))
    app.add_handler(CommandHandler("Checar", checar))
    app.add_handler(CommandHandler("Insert", insert))
    app.add_handler(CommandHandler("NovaCTO", novaCTO))
    app.add_handler(CommandHandler("Convert", convert))
    app.add_handler(CommandHandler("AjudaAdm", AjudaAdm))
    app.add_handler(CommandHandler("ListarIDs", listarIDs))
    app.add_handler(CommandHandler("Atividades", atividades))
    app.add_handler(CommandHandler("ConfigurarDrive", configdrive))
    app.add_handler(CommandHandler("Localizar", localizar_cto))
    app.add_handler(CommandHandler("ExibirCidade", ExibirCidade))
    app.add_handler(CommandHandler("AddTemplate", AdcionarTemplate))
    app.add_handler(CommandHandler("ExcluirTemplate", ExcluirTemplate))
    app.add_handler(CommandHandler("Admins", listar_admins))
    #app.add_handler(MessageHandler(filters.LOCATION, handle_location))
    app.add_handler(MessageHandler(filters.Document.ALL, handle_arquivo))
    app.add_handler(MessageHandler(filters.TEXT & ~filters.COMMAND, handle_mensagem))


    app.add_handler(CommandHandler("Ctos", ctos))
    app.add_handler(MessageHandler(filters.LOCATION, handle_ctos_location), group=1)
    app.add_handler(MessageHandler(filters.LOCATION, handle_location), group=2)

    logger.info("Automação está rodando...")
    app.run_polling()

